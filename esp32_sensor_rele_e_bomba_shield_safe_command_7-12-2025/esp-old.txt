#include <WiFi.h>
#include <Firebase_ESP_Client.h>
#include <functional>

// --------------------- CONFIG WIFI ------------------------
#define WIFI_SSID_1 "Pollini Agro"
#define WIFI_PASSWORD_1 "Polla1969@"
//
#define WIFI_SSID_2 "Rafa Bia"
#define WIFI_PASSWORD_2 "r4f4b14@"

// --------------------- CONFIG FIREBASE --------------------
#define API_KEY        "AIzaSyBunmzsROUpo8miGHs9lffr70cRwX0cY98"
#define DATABASE_URL   "https://bio-reator-default-rtdb.firebaseio.com"
#define USER_EMAIL     "velosocrew@gmail.com"
#define USER_PASSWORD  "f7bhe301516"

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
FirebaseData stream; // data object usado para stream

// ------------------- PINOS DOS RELES -------------------------
#define RELE1_PIN 14   // Rele 1 - Bomba1 (temperatura + OD)
#define RELE2_PIN 27   // Rele 2 - Bomba2 (dist√¢ncia)

// ------------------- PINOS conex√£o Arduino x Esp32 -------------------------
#define RXD2 16
#define TXD2 17

// --------- CONTROLE DA BOMBA 2 / SENSOR DE DIST√ÇNCIA ---------
bool bomba2Enchendo = false;            // indica se est√° no modo enchimento
bool permitirLeituraDistancia = false;   // se false, ignora leitura + for√ßa bomba OFF
bool bomba2Controle = false;

// -------------------- VARI√ÅVEIS CONTROLE MULTIPLICA√á√ÇO ----------------------
bool multiplicacaoAtiva = false;  // padr√£o
bool multiplicacaoAtivaAnterior = false;
String statusSistema = "desligado";

// -------------------- VARI√ÅVEIS PARA VALORES RECEBIDOS ----------------------
float temperaturaRecebida = 0.0;
float odRecebido = 0.0;
float distanciaRecebida = 0.0;

// -------------------- VARI√ÅVEIS PADR√ÉO (configur√°veis via Firebase) --------------------
float temperaturaMax = 35.0;
float temperaturaMin = 28.0;

float ODMax = 30.0;
float ODMin = 10.0;

float distanciaMin = 30.0;
float distanciaMax = 200.0;  // limite m√°ximo (exemplo)

unsigned long minutosLigado = 10;        // Y minutos (quando for ligar por tempo)
unsigned long minutosSemMudanca = 30;    // X minutos -> "X minutos desligada" (quando passar -> ligar Y)

unsigned long periodoAtivacao = 0; // em minutos (quando multiplicacao inicia)

// -------------------- VARI√ÅVEIS DE TEMPO / FLAGS --------------------
unsigned long ultimoTempoMudanca = 0;
unsigned long inicioBombaTempo = 0;
unsigned long ultimaLeituraFirebase = 0;

unsigned long inicioPeriodoAtivacao = 0;
bool periodoAtivacaoAtivo = false;

unsigned long tempoDesligadaStart = 0;
bool bombeouPorTempo = false;
bool bomba1Ligada = false;
bool bomba2Ligada = false;

// -------------------- CONTROLE MANUAL (NOVO) --------------------
// manualReleXActive: true se o usu√°rio ativou override manual (LIGAR/DESLIGAR via /comandos/releX)
// manualReleXState: estado desejado quando manual ativo (true=ligado, false=desligado)
bool manualRele1Active = false;
bool manualRele1State = false;

bool manualRele2Active = false;
bool manualRele2State = false;

// -------------------- CONFIGURA√á√ÉO DE RATE-LIMIT / RECUPERA√á√ÉO --------------------

const unsigned long FIREBASE_STATUS_INTERVAL_MS = 30000;   // enviar leituras ao Firebase a cada 30s
const unsigned long MIN_FIREBASE_WRITE_INTERVAL_MS = 250; // m√≠nimo entre chamadas seguidas ao RTDB (prote√ß√£o)
const int MAX_FIREBASE_ERROR_BEFORE_RESET = 5;

unsigned long lastAnyFirebaseWrite = 0;
unsigned long lastStatusSend = 0;
int firebaseErrorCount = 0;

// Convers√£o
unsigned long toMS(unsigned long min) { return min * 60000UL; }

// ----- forward
void safeRestartFirebaseStream();
const char* getTokenStatus(firebase_auth_token_status status);

// ----------------- NOVAS VARI√ÅVEIS/CONST PARA safeCommand -----------------
unsigned long safe_lastWrite = 0;
const unsigned long SAFE_WRITE_INTERVAL_MS = 250; // mesmo que MIN_FIREBASE_WRITE_INTERVAL_MS
const int SAFE_MAX_RETRIES = 3;

// manter o √∫ltimo status do token atualizado pelo callback
firebase_auth_token_status lastTokenStatus = token_status_uninitialized;

// ----------------------- HELPERS FIREBASE (RE-IMPLEMENTADOS) -----------------------

// fun√ß√£o central que executa uma opera√ß√£o de escrita de forma segura
bool safeCommand(std::function<bool(FirebaseData*)> func, const char* path = "") {
  unsigned long now = millis();

  // 1) Prote√ß√£o WiFi
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö† safeCommand: WiFi desconectado, abortando write.");
    return false;
  }

  // 2) Aguarda token READY (com timeout curto)
  if (lastTokenStatus != token_status_ready) {
    Serial.printf("‚è≥ safeCommand: token n√£o pronto (%s). Aguardando...\n", getTokenStatus(lastTokenStatus));
    unsigned long waitStart = millis();
    bool ready = false;
    while (millis() - waitStart < 2000) { // espera at√© 2s no m√°ximo por token ficar pronto
      if (lastTokenStatus == token_status_ready) { ready = true; break; }
      delay(100);
    }
    if (!ready) {
      Serial.println("‚ùå safeCommand: token ainda n√£o pronto ap√≥s timeout. Abortando write.");
      return false;
    }
  }

  // 3) Respeita intervalo m√≠nimo entre writes
  if (now - safe_lastWrite < SAFE_WRITE_INTERVAL_MS) {
    unsigned long toWait = SAFE_WRITE_INTERVAL_MS - (now - safe_lastWrite);
    delay(toWait);
  }
  safe_lastWrite = millis();

  // 4) Tenta executar a opera√ß√£o com retries curtos
  int attempt = 0;
  while (attempt < SAFE_MAX_RETRIES) {
    if (func(&fbdo)) {
      firebaseErrorCount = 0; // sucesso -> reset contador de erros globais
      return true;
    }
    // falhou
    Serial.printf("‚ùå safeCommand erro (%s) path: %s (HTTP %d) tentativa %d\n",
                  fbdo.errorReason().c_str(), path, fbdo.httpCode(), attempt + 1);
    firebaseErrorCount++;
    attempt++;

    // 5) Se muitos erros -> reinicia stream / firebase para tentar recuperar
    if (firebaseErrorCount >= MAX_FIREBASE_ERROR_BEFORE_RESET) {
      Serial.println("‚ö† Muitos erros Firebase ‚Äî reiniciando conex√£o Firebase/Stream...");
      safeRestartFirebaseStream();
      // ap√≥s restart, sai para evitar loop com token n√£o pronto
      return false;
    }

    delay(200 + attempt * 100);
  }

  return false;
}

// wrappers pr√°ticos
bool safeSetString(const char* path, const String &value) {
  return safeCommand([&](FirebaseData* fb) {
    return Firebase.RTDB.setString(fb, path, value.c_str());
  }, path);
}

bool safeSetFloat(const char* path, float value) {
  return safeCommand([&](FirebaseData* fb) {
    return Firebase.RTDB.setFloat(fb, path, value);
  }, path);
}

bool safeSetBool(const char* path, bool value) {
  return safeCommand([&](FirebaseData* fb) {
    return Firebase.RTDB.setBool(fb, path, value);
  }, path);
}

bool safeSetInt(const char* path, int value) {
  return safeCommand([&](FirebaseData* fb) {
    return Firebase.RTDB.setInt(fb, path, value);
  }, path);
}

bool safeSetTimestamp(const char* path) {
  return safeCommand([&](FirebaseData* fb) {
    return Firebase.RTDB.setTimestamp(fb, path);
  }, path);
}

// ----------------------- CONEX√ÉO WIFI COM FALLBACK -----------------------
bool conectarWiFi() {
  Serial.println("\nüì° Tentando conectar na Rede 1...");
  WiFi.disconnect(true);
  WiFi.begin(WIFI_SSID_1, WIFI_PASSWORD_1);

  unsigned long inicio = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - inicio < 10000) {
    delay(300);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ Conectado na Rede 1!");
    return true;
  }

  // Se falhou, tenta a rede 2
  Serial.println("\n‚ö† Falha ao conectar √† Rede 1. Tentando Rede 2...");

  WiFi.disconnect(true);
  WiFi.begin(WIFI_SSID_2, WIFI_PASSWORD_2);

  inicio = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - inicio < 10000) {
    delay(300);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ Conectado na Rede 2!");
    return true;
  }

  Serial.println("\n‚ùå N√£o foi poss√≠vel conectar a nenhuma rede.");
  return false;
}

// ----------------------- CONTROLE BOMBA 1 (Temp + OD) -----------------------
void ligarBomba1(bool porTempo = false, const char* motivo = "") {
  digitalWrite(RELE1_PIN, LOW); // rele ativo em LOW (conforme seu hardware)
  bomba1Ligada = true;
  bombeouPorTempo = porTempo;
  if (porTempo) inicioBombaTempo = millis();
  tempoDesligadaStart = 0;

  safeSetString("/status/bomba1", "LIGADA");
  if (motivo && strlen(motivo) > 0) {
    safeSetString("/status/bomba1_motivo", String(motivo));
    Serial.printf("‚û°Ô∏è Bomba1 LIGADA (porTempo=%d) motivo: %s\n", porTempo ? 1 : 0, motivo);
  } else {
    safeSetString("/status/bomba1_motivo", "Indefinido");
    Serial.printf("‚û°Ô∏è Bomba1 LIGADA (porTempo=%d) motivo: Indefinido\n", porTempo ? 1 : 0);
  }
}

void desligarBomba1(const char* motivo = "") {
  digitalWrite(RELE1_PIN, HIGH);
  bomba1Ligada = false;
  bombeouPorTempo = false;
  tempoDesligadaStart = millis();

  safeSetString("/status/bomba1", "DESLIGADA");
  if (motivo && strlen(motivo) > 0) {
    safeSetString("/status/bomba1_motivo", String(motivo));
    Serial.printf("‚õî Bomba1 DESLIGADA motivo: %s\n", motivo);
  } else {
    safeSetString("/status/bomba1_motivo", "Indefinido");
    Serial.println("‚õî Bomba1 DESLIGADA motivo: Indefinido");
  }
}

// ----------------------- CONTROLE BOMBA 2 (Dist√¢ncia) -----------------------
void ligarBomba2(const char* motivo = "") {
  digitalWrite(RELE2_PIN, LOW);
  bomba2Ligada = true;
  safeSetString("/status/bomba2", "LIGADA");
  if (motivo && strlen(motivo) > 0) safeSetString("/status/bomba2_motivo", String(motivo));
  Serial.println("‚û°Ô∏è Bomba2 LIGADA (dist√¢ncia)");
}

void desligarBomba2(const char* motivo = "") {
  digitalWrite(RELE2_PIN, HIGH);
  bomba2Ligada = false;
  safeSetString("/status/bomba2", "DESLIGADA");
  if (motivo && strlen(motivo) > 0) safeSetString("/status/bomba2_motivo", String(motivo));
  Serial.println("‚õî Bomba2 DESLIGADA (dist√¢ncia)");
}

// ----------- DESLIGAR COMPLETAMENTE O CONTROLE DA BOMBA2 ----------
void desligarControleBomba2() {
  Serial.println("‚õî Controle da Bomba2 DESATIVADO manualmente.");

  // Desliga fisicamente apenas se N√ÉO houver override manual:
  if (!manualRele2Active) {
    desligarBomba2("Controle desativado");
  } else {
    // se manual ativo, apenas atualiza status indicando que controle autom√°tico est√° DESATIVADO
    safeSetString("/status/bomba2_controle", "DESATIVADO (AUTO) - manual override presente");
    Serial.println("‚ö† Controle autom√°tico da bomba2 DESATIVADO, mas override manual est√° presente (n√£o desligando).");
  }

  // Bloqueia qualquer reativa√ß√£o pelo sensor (a menos que o manual esteja ativo)
  bomba2Enchendo = false;
  permitirLeituraDistancia = false;

  safeSetString("/status/bomba2_controle", "DESATIVADO");
}

// ----------- ATIVAR O CONTROLE DA BOMBA2 NOVAMENTE -----------------
void ativarControleBomba2() {
  Serial.println("‚û°Ô∏è Controle da Bomba2 ATIVADO manualmente.");
  // se manual ativo, nao mexer no estado f√≠sico
  if (!manualRele2Active) {
    permitirLeituraDistancia = true;
    bomba2Enchendo = true;
    safeSetString("/status/bomba2_controle", "ATIVADO");
  } else {
    Serial.println("‚ö† Controle autom√°tico ativado mas override manual presente (n√£o alterando rele2).");
    safeSetString("/status/bomba2_controle", "ATIVADO (AUTO) - manual override presente");
  }
}

void lerPermitDistanciaFirebase() {
  if (Firebase.RTDB.getBool(&fbdo, "/config/permitirLeituraDistancia")) {
      permitirLeituraDistancia = fbdo.boolData();
  }
}

// -------------------- VALIDA SENSORES ------------------------
bool sensoresValidos() {
  if (temperaturaRecebida <= 0 || odRecebido <= 0 || distanciaRecebida <= 0) {
    Serial.println("‚ö† ALERTA: Leitura inv√°lida detectada (0 ou negativo).");
    return false;
  }
  if (temperaturaRecebida < -10 || temperaturaRecebida > 100) {
    Serial.println("‚ö† Sensor de temperatura fora do intervalo.");
    return false;
  }
  if (odRecebido < 0 || odRecebido > 1000) {
    Serial.println("‚ö† Sensor OD fora do intervalo.");
    return false;
  }
  // se periodoAtivacao e multiplicacaoAtiva, ignorar valida√ß√£o de dist√¢ncia
  if (periodoAtivacaoAtivo && multiplicacaoAtiva) {
    Serial.println("‚ö† RETORNANDO TRUE");
    return true;
  } else {
    if (distanciaRecebida < 0 || distanciaRecebida > distanciaMax) {
      Serial.println("‚ö† Sensor de dist√¢ncia fora do intervalo.");
      // se manual ativo para rele2, nao for√ßar desligamento f√≠sico; apenas log e retorno false.
      if (!manualRele2Active) desligarBomba2("‚ö† Sensor de dist√¢ncia fora do intervalo.");
      return false;
    }
  }
  return true;
}

// -------------------- BOT√ÉO DE SEGURAN√áA ------------------------
void desligarTodasBombasPorSeguranca() {
  Serial.println("üõë MODO DE SEGURAN√áA ATIVO: Todas as bombas desligadas.");

  // Respeitar override manual: s√≥ desligar as bombas cujo manual N√ÉO esteja ativo
  if (!manualRele1Active) {
    desligarBomba1("Seguran√ßa: sistema desligado");
  } else {
    Serial.println("‚ö† Bomba1 em override manual ‚Äî n√£o ser√° desligada pela seguran√ßa.");
    safeSetString("/status/bomba1_motivo", "Seguran√ßa solicitada, mas override manual presente");
  }

  if (!manualRele2Active) {
    desligarBomba2("Seguran√ßa: sistema desligado");
  } else {
    Serial.println("‚ö† Bomba2 em override manual ‚Äî n√£o ser√° desligada pela seguran√ßa.");
    safeSetString("/status/bomba2_motivo", "Seguran√ßa solicitada, mas override manual presente");
  }

  bombeouPorTempo = false;
  periodoAtivacaoAtivo = false;
}

// -------------------- LER CONFIG DO FIREBASE ------------------------
void atualizarConfigFirebase() {
  Serial.println("üîÑ Atualizando vari√°veis de configura√ß√£o do Firebase...");

  // Temperatura
  if (Firebase.RTDB.getFloat(&fbdo, "/config/temperatura_max")) {
    temperaturaMax = fbdo.floatData();
  } else {
    Serial.println("‚ö† /config/temperatura_max n√£o encontrado (mantendo padr√£o).");
  }

  if (Firebase.RTDB.getFloat(&fbdo, "/config/temperatura_min")) {
    temperaturaMin = fbdo.floatData();
  } else {
    Serial.println("‚ö† /config/temperatura_min n√£o encontrado (mantendo padr√£o).");
  }

  // Tempo
  if (Firebase.RTDB.getInt(&fbdo, "/config/intervalo_ligado")) {
    minutosLigado = fbdo.intData();
  } else {
    Serial.println("‚ö† /config/intervalo_ligado n√£o encontrado (mantendo padr√£o).");
  }

  if (Firebase.RTDB.getInt(&fbdo, "/config/intervalo_sem_mudanca")) {
    minutosSemMudanca = fbdo.intData();
  } else {
    Serial.println("‚ö† /config/intervalo_sem_mudanca n√£o encontrado (mantendo padr√£o).");
  }

  // OD
  if (Firebase.RTDB.getFloat(&fbdo, "/config/od_max")) {
    ODMax = fbdo.floatData();
  } else {
    Serial.println("‚ö† /config/od_max n√£o encontrado (mantendo padr√£o).");
  }

  if (Firebase.RTDB.getFloat(&fbdo, "/config/od_min")) {
    ODMin = fbdo.floatData();
  } else {
    Serial.println("‚ö† /config/od_min n√£o encontrado (mantendo padr√£o).");
  }

  // Dist√¢ncia
  if (Firebase.RTDB.getFloat(&fbdo, "/config/distancia_min")) {
      distanciaMin = fbdo.floatData();
  } else {
      // cria via safeSetFloat
      safeSetFloat("/config/distancia_min", distanciaMin);
      Serial.println("Criado /config/distancia_min (padr√£o)");
  }

  if (Firebase.RTDB.getFloat(&fbdo, "/config/distancia_max")) {
      distanciaMax = fbdo.floatData();
  } else {
      safeSetFloat("/config/distancia_max", distanciaMax);
      Serial.println("Criado /config/distancia_max (padr√£o)");
  }

  // Controle dist√¢ncia
  if (Firebase.RTDB.getBool(&fbdo, "/config/bomba2_controle")) {
      bomba2Controle = fbdo.boolData();
  } else {
      safeSetBool("/config/bomba2_controle", false);
      bomba2Controle = false;
      Serial.println("Criado /config/bomba2_controle = false");
  }

  if (Firebase.RTDB.getBool(&fbdo, "/config/permitirLeituraDistancia")) {
      permitirLeituraDistancia = fbdo.boolData();
  } else {
      Serial.println("‚ö† Campo 'permitirLeituraDistancia' n√£o encontrado. Criando como false.");
      safeSetBool("/config/permitirLeituraDistancia", false);
      permitirLeituraDistancia = false;
  }


  // Periodo de ativacao
  if (Firebase.RTDB.getInt(&fbdo, "/config/periodo_ativacao")) {
    periodoAtivacao = fbdo.intData(); // minutos
  } else {
    safeSetInt("/config/periodo_ativacao", (int)periodoAtivacao);
    Serial.println("Criado /config/periodo_ativacao (padr√£o 0)");
  }

  // Multiplicacao
  if (Firebase.RTDB.getBool(&fbdo, "/config/multiplicacao")) {
      multiplicacaoAtiva = fbdo.boolData();
  } else {
      Serial.println("‚ö† Campo 'multiplicacao' n√£o encontrado. Criando como false.");
      safeSetBool("/config/multiplicacao", false);
      multiplicacaoAtiva = false;
  }

  // Atualiza status geral
  safeSetString("/status/sistema", multiplicacaoAtiva ? "ligado" : "desligado");

  Serial.println("‚úî Configura√ß√µes atualizadas:");
  Serial.printf("TempMax: %.2f\n", temperaturaMax);
  Serial.printf("TempMin: %.2f\n", temperaturaMin);
  Serial.printf("Ligado(Y): %lu min\n", minutosLigado);
  Serial.printf("Desligada(X): %lu min\n", minutosSemMudanca);
  Serial.printf("ODMax: %.2f\n", ODMax);
  Serial.printf("ODMin: %.2f\n", ODMin);
  Serial.printf("distanciaMin: %.2f\n", distanciaMin);
  Serial.printf("distanciaMax: %.2f\n", distanciaMax);
  Serial.printf("bomba2Controle: %d\n", bomba2Controle);
  Serial.printf("permitirLeituraDistancia: %d\n", permitirLeituraDistancia);
  Serial.printf("periodoAtivacao: %lu min\n", periodoAtivacao);
  Serial.printf("multiplicacao Ativa: %d\n", multiplicacaoAtiva);
}

// ---------------------- FIREBASE CALLBACK -------------------------------
void tokenStatusCallback(TokenInfo info) {
  // atualiza o status global do token para que safeCommand saiba se pode escrever
  lastTokenStatus = info.status;
  Serial.printf("TokenStatus: %s\n", getTokenStatus(info.status));
}

const char* getTokenStatus(firebase_auth_token_status status) {
  switch (status) {
    case token_status_uninitialized: return "Uninitialized";
    case token_status_on_signing: return "Signing";
    case token_status_on_refresh: return "Refreshing";
    case token_status_ready: return "Ready";
    case token_status_error: return "Error";
    default: return "Unknown";
  }
}

// ---------------------- GEST√ÉO E RECONEX√ÉO FIREBASE/STREAM ------------------
void safeRestartFirebaseStream() {
  Serial.println("üîÅ Reiniciando Firebase (begin) e Stream...");

  // Encerrar stream se estiver conectado (usa httpConnected)
  if (stream.httpConnected()) {
    Firebase.RTDB.endStream(&stream);
    delay(200);
  }

  // Reconnect WiFi se necess√°rio
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö† WiFi desconectado ao reiniciar Firebase. Tentando reconectar WiFi...");
    WiFi.disconnect();
    conectarWiFi();
    //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    unsigned long start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
      delay(200);
    }
  }

  // Recome√ßar Firebase
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  delay(200);

  // Reiniciar stream em /comandos
  if (!Firebase.RTDB.beginStream(&stream, "/comandos")) {
    Serial.printf("‚ùå Erro ao iniciar stream: %s\n", stream.errorReason().c_str());
  } else {
    Serial.println("‚úî Stream reiniciado em /comandos");
  }

  // reset contador de erros
  firebaseErrorCount = 0;
}

void garantirComandosFirebase() {
  Serial.println("üîç Verificando exist√™ncia de /comandos/rele1 e /comandos/rele2...");

  // RELE1 deve ser string
  String tmp;
  if (!Firebase.RTDB.getString(&fbdo, "/comandos/rele1")) {
    Serial.println("‚ö† /comandos/rele1 n√£o existe ‚Äî criando valor padr√£o AUTO");
    safeSetString("/comandos/rele1", "AUTO");
  }

  // RELE2 deve ser string
  if (!Firebase.RTDB.getString(&fbdo, "/comandos/rele2")) {
    Serial.println("‚ö† /comandos/rele2 n√£o existe ‚Äî criando valor padr√£o AUTO");
    safeSetString("/comandos/rele2", "AUTO");
  }

  Serial.println("‚úî Comandos garantidos no Firebase.");
}

// -------------------- SETUP ------------------------
void setup() {
  Serial.begin(115200);
  Serial2.begin(9600, SERIAL_8N1, RXD2, TXD2);

  pinMode(RELE1_PIN, OUTPUT);
  pinMode(RELE2_PIN, OUTPUT);

  // Garantir estado inicial (reles HIGH = desligado)
  digitalWrite(RELE1_PIN, HIGH);
  digitalWrite(RELE2_PIN, HIGH);

  // WiFi
  Serial.print("Conectando ao WiFi...");
  conectarWiFi();
  //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  unsigned long wifiStart = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
    if (millis() - wifiStart > 15000) {
      Serial.println("\n‚ö† Timeout conectando WiFi. Tentando de novo...");
      wifiStart = millis();
      WiFi.disconnect();
      conectarWiFi();
      //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    }
  }
  Serial.println("\nWiFi conectado!");

  // Firebase
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  Serial.println("üî• Firebase inicializado!");

  garantirComandosFirebase();

  ultimoTempoMudanca = millis();
  atualizarConfigFirebase(); // carrega valores do Firebase na inicializa√ß√£o

  // INICIAR STREAM PARA OUVIR COMANDOS DO DASHBOARD
  if (!Firebase.RTDB.beginStream(&stream, "/comandos")) {
    Serial.println("‚ùå Erro ao iniciar stream!");
    Serial.println(stream.errorReason());
  } else {
    Serial.println("‚úî Stream iniciado em /comandos");
  }

  // se multiplicacao j√° estiver ativa no startup, vamos ativar periodo caso exista
  multiplicacaoAtivaAnterior = multiplicacaoAtiva;
  if (multiplicacaoAtiva && periodoAtivacao > 0) {
    periodoAtivacaoAtivo = true;
    inicioPeriodoAtivacao = millis();
    Serial.printf("üîî Multiplica√ß√£o j√° ativa na inicializa√ß√£o: periodoAtivacao de %lu min iniciado\n", periodoAtivacao);

    if (odRecebido < ODMax && !bomba1Ligada && !manualRele1Active) {
      ligarBomba1(true);
    } else if (!(odRecebido < ODMax)) {
      Serial.println("‚ö† OD j√° >= ODMax na inicializa√ß√£o: bomba1 permanecer√° desligada mesmo no periodo de ativacao.");
    }
    // se manualRele1Active, respeitar manual
  }
}

// -------------------- LOOP ------------------------
void loop() {
  // ============================================================
  // üîî OUVIR COMANDOS DO DASHBOARD (STREAM DO FIREBASE)
  // ============================================================
  Firebase.RTDB.readStream(&stream);

  if (stream.streamAvailable()) {
    String path = stream.dataPath();
    String data = stream.stringData();

    Serial.print("üì° Stream recebido: ");
    Serial.print(path);
    Serial.print(" ‚Üí ");
    Serial.println(data);

    // Quando o dashboard clicar "Atualizar ESP32 agora"
    if (path == "/atualizar") {
      Serial.println("üî• COMANDO RECEBIDO: Atualizar configura√ß√µes agora!");
      atualizarConfigFirebase();   // atualiza configura√ß√µes
      safeSetTimestamp("/status/ultima_atualizacao");
      Serial.println("‚úî Configura√ß√µes atualizadas via comando remoto.");
    }

    // --- desligar controle da bomba2 (controle autom√°tico) ---
    if (path == "/bomba2_controle" && data == "desligar") {
      desligarControleBomba2();
    }

    // --- ativar controle da bomba2 (controle autom√°tico) ---
    if (path == "/bomba2_controle" && data == "ligar") {
      ativarControleBomba2();
    }

    // ----------------- NOVOS COMANDOS MANUAIS PARA RELES -----------------
    // path √© relativo a "/comandos", mas stream.dataPath() retornar√° por exemplo "/rele1" quando voc√™ escreve em /comandos/rele1
    if (path == "/rele1") {
      if (data.equalsIgnoreCase("LIGAR")) {
        manualRele1Active = true;
        manualRele1State = true;
        ligarBomba1(false, "Comando manual (/comandos/rele1 = LIGAR)");
        safeSetString("/status/rele1_manual", "MANUAL_LIGADA");
        Serial.println("‚úÖ Override manual RELE1: LIGAR (manual ativo)");
      } else if (data.equalsIgnoreCase("DESLIGAR")) {
        manualRele1Active = true;
        manualRele1State = false;
        desligarBomba1("Comando manual (/comandos/rele1 = DESLIGAR)");
        safeSetString("/status/rele1_manual", "MANUAL_DESLIGADA");
        Serial.println("‚úÖ Override manual RELE1: DESLIGAR (manual ativo)");
      } else if (data.equalsIgnoreCase("AUTO")) {
        manualRele1Active = false; // libera controle autom√°tico imediatamente
        safeSetString("/status/rele1_manual", "AUTO (manual desligado)");
        Serial.println("üîÅ RELE1: modo AUTO (override manual removido). Controle autom√°tico retorna imediatamente.");
      } else {
        Serial.println("‚ö† Comando desconhecido para /rele1. Use LIGAR / DESLIGAR / AUTO.");
      }
    }

    if (path == "/rele2") {
      if (data.equalsIgnoreCase("LIGAR")) {
        manualRele2Active = true;
        manualRele2State = true;
        ligarBomba2("Comando manual (/comandos/rele2 = LIGAR)");
        safeSetString("/status/rele2_manual", "MANUAL_LIGADA");
        Serial.println("‚úÖ Override manual RELE2: LIGAR (manual ativo)");
      } else if (data.equalsIgnoreCase("DESLIGAR")) {
        manualRele2Active = true;
        manualRele2State = false;
        desligarBomba2("Comando manual (/comandos/rele2 = DESLIGAR)");
        safeSetString("/status/rele2_manual", "MANUAL_DESLIGADA");
        Serial.println("‚úÖ Override manual RELE2: DESLIGAR (manual ativo)");
      } else if (data.equalsIgnoreCase("AUTO")) {
        manualRele2Active = false; // libera controle autom√°tico imediatamente
        safeSetString("/status/rele2_manual", "AUTO (manual desligado)");
        Serial.println("üîÅ RELE2: modo AUTO (override manual removido). Controle autom√°tico retorna imediatamente.");
      } else {
        Serial.println("‚ö† Comando desconhecido para /rele2. Use LIGAR / DESLIGAR / AUTO.");
      }
    }

  } else {
    // Se stream n√£o estiver conectado, tentar reiniciar periodicamente
    if (!stream.httpConnected()) {
      static unsigned long lastTryStream = 0;
      if (millis() - lastTryStream > 15000) { // a cada 15s tentar reiniciar
        lastTryStream = millis();
        Serial.println("‚ö† Stream n√£o ativo. Tentando reiniciar stream...");
        safeRestartFirebaseStream();
      }
    }
  }

  // ============================================================
  //  RECEBER DADOS DO ARDUINO UNO
  // ============================================================
  if (Serial2.available()) {
    String linha = Serial2.readStringUntil('\n');

    int i1 = linha.indexOf("Temp=");
    int i2 = linha.indexOf(";", i1);
    if (i1 >= 0 && i2 > i1) temperaturaRecebida = linha.substring(i1 + 5, i2).toFloat();

    i1 = linha.indexOf("OD=");
    i2 = linha.indexOf(";", i1);
    if (i1 >= 0 && i2 > i1) odRecebido = linha.substring(i1 + 3, i2).toFloat();

    i1 = linha.indexOf("Dist=");
    i2 = linha.indexOf(";", i1);
    if (i1 >= 0 && i2 > i1) distanciaRecebida = linha.substring(i1 + 5, i2).toFloat();
  }

  // Print para confer√™ncia
  Serial.printf("Temp: %.2f | OD: %.2f | Dist: %.2f\n",
                temperaturaRecebida, odRecebido, distanciaRecebida);

  // Envia para Firebase periodicamente (rate-limited)
  // -----------------------------------------------------------
  // 1) ENVIO DE DIST√ÇNCIA ‚Äî SUPER R√ÅPIDO (200ms ou o valor que quiser)

  unsigned long now = millis();
  if (now - lastStatusSend >= FIREBASE_STATUS_INTERVAL_MS) {
    lastStatusSend = now;

    // envia apenas se WiFi conectado
    if (WiFi.status() == WL_CONNECTED) {
      safeSetFloat("/status/temperatura", temperaturaRecebida);
      safeSetFloat("/status/od", odRecebido);
      safeSetFloat("/status/distancia", distanciaRecebida);
      safeSetTimestamp("/status/ultima_atualizacao");
    } else {
      Serial.println("‚ö† WiFi n√£o conectado, pulando envio de status.");
      // tenta reconectar WiFi
      WiFi.disconnect();
      conectarWiFi();
      //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    }
  }

  // Se multiplica√ß√£o desligada -> seguran√ßa e leitura ocasional do config
  if (!multiplicacaoAtiva) {
    Serial.println("‚ö† MODO DESLIGADO ‚Äî Sistema bloqueado.");

    // Alterado: respeitar overrides manuais (n√£o desligar reles em override)
    desligarTodasBombasPorSeguranca();

    // Continua lendo Firebase mesmo com o sistema desligado!
    if (millis() - ultimaLeituraFirebase > 3000) {
        ultimaLeituraFirebase = millis();
        if (WiFi.status() == WL_CONNECTED) {
          atualizarConfigFirebase();
        } else {
          Serial.println("‚ö† WiFi desconectado -> tentarei reconectar.");
          conectarWiFi();
          //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
        }
    }

    delay(500);
    return;
  }

  // Se houve mudan√ßa no flag multiplicacao (in√≠cio), tratar periodo de ativacao
  if (multiplicacaoAtiva && !multiplicacaoAtivaAnterior) {
    Serial.println("üîî Multiplica√ß√£o ativada agora!");
    if (periodoAtivacao > 0) {
      periodoAtivacaoAtivo = true;
      inicioPeriodoAtivacao = millis();
      Serial.printf("‚è± Periodo de ativacao iniciado: %lu minutos\n", periodoAtivacao);

      // somente ligar por periodo se n√£o houver override manual em bomba1
      if (odRecebido < ODMax) {
        if (!bomba1Ligada && !manualRele1Active) ligarBomba1(true, "Periodo de ativacao (inicio)");
      } else {
        Serial.println("‚ö† OD >= ODMax no inicio do periodo: bomba1 ficar√° OFF (prioridade OD).");
        if (!manualRele1Active) desligarBomba1("OD >= ODMax (periodo inicio)");
      }
    }
  }
  multiplicacaoAtivaAnterior = multiplicacaoAtiva;

  // ==========================================
  // 2) Verificar se sensores est√£o v√°lidos
  // ==========================================
  if (!sensoresValidos()) {
    delay(1000);
    return;
  }

  lerPermitDistanciaFirebase();

  // CONTROLE AUTOM√ÅTICO DA BOMBA2 BASEADO EM CONFIG DO FIREBASE
  if (bomba2Controle) {
      ativarControleBomba2();
  } else {
      desligarControleBomba2();
  }

  // -------------------- CONTROLE CONDICIONAL DA BOMBA2 --------------------
  if (manualRele2Active) {
    // Se override manual ativo, garante estado manual e n√£o permite autom√°tico alterar
    if (manualRele2State && !bomba2Ligada) {
      ligarBomba2("Override manual ativo: ligar");
    } else if (!manualRele2State && bomba2Ligada) {
      desligarBomba2("Override manual ativo: desligar");
    }
    // n√£o executar l√≥gica autom√°tica abaixo
  } else {
    // Se n√£o h√° override manual, executar a l√≥gica autom√°tica normal
    if (permitirLeituraDistancia) {
      // ============================================================
      //  CONTROLE BOMBA 2 (DIST√ÇNCIA)
      // ============================================================
      if (distanciaRecebida > distanciaMin && !bomba2Ligada) {
          ligarBomba2("Dist√¢ncia acima do m√≠nimo");
      }
      else if (distanciaRecebida <= distanciaMin && bomba2Ligada) {
          desligarBomba2("Dist√¢ncia abaixo ou igual ao m√≠nimo");
      }
      else if (distanciaRecebida > distanciaMax && bomba2Ligada) {
          desligarBomba2("Dist√¢ncia acima do m√°ximo (seguran√ßa)");
      }
    } else {
      // Se o controle estiver desativado, garante bomba desligada
      if (bomba2Ligada) {
          desligarBomba2("controle desativado");
      }
    }
  }

  // ======================================================================
  // L√ìGICA BOMBA 1 (TEMPERATURA + OD + PERIODOS)
  // ======================================================================
  if (manualRele1Active) {
    // Se override manual ativo, apenas garantir estado manual e IGNORAR toda a l√≥gica autom√°tica
    if (manualRele1State && !bomba1Ligada) {
      ligarBomba1(false, "Override manual ativo: ligar");
    } else if (!manualRele1State && bomba1Ligada) {
      desligarBomba1("Override manual ativo: desligar");
    }
  } else {
    // Sem override manual, executar l√≥gica autom√°tica normal
    if (odRecebido >= ODMax) {
      if (bomba1Ligada) {
        Serial.println("‚ö† OD >= ODMax -> For√ßando DESLIGAR bomba1 (prioridade OD).");
        desligarBomba1("OD >= ODMax (prioridade)");
      }
    } else {
      if (temperaturaRecebida < temperaturaMin) {
        if (bomba1Ligada) {
          Serial.println("Temp abaixo do m√≠nimo -> desligando bomba1.");
          desligarBomba1("Temperatura abaixo do m√≠nimo");
        }
      } else if (temperaturaRecebida > temperaturaMax) {
        if (!bomba1Ligada) {
          Serial.println("Temp acima do max -> tentando LIGAR bomba1 (OD permite).");
          ligarBomba1(false, "Temperatura acima do m√°ximo");
        }
      } else {
        // temp entre min e max
        if (periodoAtivacaoAtivo) {
          unsigned long tempoPeriodo = millis() - inicioPeriodoAtivacao;
          if (tempoPeriodo >= toMS(periodoAtivacao)) {
            periodoAtivacaoAtivo = false;
            Serial.println("‚è≥ Periodo de ativacao finalizado. Voltando √†s regras normais.");
          } else {
            if (!bomba1Ligada) {
              Serial.println("üîî Periodo de ativacao ativo -> ligando bomba1 (periodo).");
              ligarBomba1(true, "Periodo de ativacao (ativo)");
            }
          }
        }

        if (!periodoAtivacaoAtivo) {
          if (!bomba1Ligada) {
            if (tempoDesligadaStart == 0) {
              tempoDesligadaStart = millis();
              Serial.println("‚ñ∂ Contador de tempo desligada da bomba1 iniciado.");
            } else {
              unsigned long tempoDesligadaAtual = millis() - tempoDesligadaStart;
              if (!bomba1Ligada && !bombeouPorTempo && tempoDesligadaAtual >= toMS(minutosSemMudanca)) {
                if (odRecebido < ODMax) {
                  Serial.println("‚è± Bomba1 ficou X minutos desligada -> ligando por Y minutos (regra tempo desligada).");
                  ligarBomba1(true, "Regra: X minutos desligada -> ligar Y minutos");
                } else {
                  Serial.println("‚ö† Tentativa de ligar por tempo bloqueada: OD >= ODMax.");
                }
              }
            }
          } else {
            if (bombeouPorTempo) {
              unsigned long tempoLigadaAtual = millis() - inicioBombaTempo;
              if (tempoLigadaAtual >= toMS(minutosLigado)) {
                Serial.println("‚è≤ Tempo ligado por regra expirou -> desligando bomba1.");
                desligarBomba1("Tempo ligado por regra expirou");
              }
            } else {
              tempoDesligadaStart = 0;
            }
          }
        }
      }
    }
  }

  // ============================================================
  // ATUALIZA FIREBASE CONFIG UPDATE a cada 10s
  // ============================================================
  if (millis() - ultimaLeituraFirebase > 10000) {
    ultimaLeituraFirebase = millis();
    if (WiFi.status() == WL_CONNECTED) {
      atualizarConfigFirebase();
    } else {
      Serial.println("‚ö† WiFi desconectado -> tentando reconectar.");
      conectarWiFi();
      //WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    }
  }

  delay(200); // pausa curta para aliviar CPU
}